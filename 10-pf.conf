filter {
  if "pf" in [tags] {
    if [prog] =~ /^filterlog/ {
      grok {
        #PFsense
        #match => [ "message", "<(?<evtid>.*)>(?<datetime>(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9]) (?:2[0123]|[01]?[0-9]):(?:[0-5][0-9]):(?:[0-5][0-9])) (?<prog>.*?): (?<msg>.*)" ]
        #OPNsense
        match => [ "message", "<(?<evtid>.*)>(?<datetime>(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9]) (?:2[0123]|[01]?[0-9]):(?:[0-5][0-9]):(?:[0-5][0-9])) (?<firewall>.*?) (?<prog>.*?): (?<msg>.*)" ]
      }
      #Source
      mutate {
        add_field => { "[source][ip]" => "%{src_ip}"}
        add_field => { "[source][address]" => "%{src_ip}"}
        add_field => { "[source][port]" => "%{src_port}"}
        add_field => { "[source][port]" => "%{src_port}"}
      }
      cidr {
        address => [ "%{[src_ip]}" ]
        network => [ "0.0.0.0/32", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128", "169.254.0.0/16", "fe80::/10", "224.0.0.0/4", "ff00::/8", "255.255.255.255/32", "::" ]
        add_field => { "[@metadata][src_locality]" => "private" }
      }
      if ![@metadata][src_locality] {
        geoip {
          add_tag => [ "GeoIP" ]
          source => "src_ip"
          database => "/etc/logstash/GeoLite2-City.mmdb"
          target => [source][geo]
        }
      }
      #Network
      mutate {
        add_field => { "[network][direction]" => "%{direction}bound"}
        add_field => { "[network][iana_number]" => "%{proto_id}"}
        add_field => { "[network][proto]" => "%{transport}"}
        add_field => { "[network][type]" => "ipv%{ip_ver}"}
      }



      mutate {
        gsub => ["datetime","  "," "]
      }
      date {
        match => [ "datetime", "MMM dd HH:mm:ss" ]
        timezone => "America/New_York"
      }
      mutate {
        replace => [ "message", "%{msg}" ]
      }
      mutate {
        remove_field => [ "msg", "datetime" ]
      }
    }
    if [prog] =~ /^dhcpd$/ {
      mutate {
        add_tag => [ "dhcpd" ]
      }
      grok {
        patterns_dir => ["/etc/logstash/conf.d/patterns"]
        match => [ "message", "%{DHCPD}"]
      }
    }
    if [prog] =~ /^suricata/ {
      mutate {
        add_tag => [ "Suricata" ]
      }
      if [message] =~ "\A\{.+\}\z" {
        json {
          source => "message"
          target => "[suricata][eve]"
        }
        if ![source.ip] {
          mutate {
            add_field => { "[source][ip]" => "%{[suricata][eve][src_ip]}"}
          }
        }
        if ![destination.ip] {
          mutate {
            add_field => { "[destination][ip]" => "%{[suricata][eve][dest_ip]}"}
          }
        }
        if ![source.port] {
          mutate {
            add_field => { "[source][port]" => "%{[suricata][eve][src_port]}"}
          }
        }
        if ![destination.port] {
          mutate {
            add_field => { "[destination][port]" => "%{[suricata][eve][dest_port]}"}
          }
        }
      } else {
        grok {
          patterns_dir => ["/etc/logstash/conf.d/patterns"]
          match => [ "message", "%{SURICATA}"]
        }
      }

      if ![geoip] and [src_ip] {
        # Check if source IP address is private.
        cidr {
          address => [ "%{[src_ip]}" ]
          network => [ "0.0.0.0/32", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128", "169.254.0.0/16", "fe80::/10", "224.0.0.0/4", "ff00::/8", "255.255.255.255/32", "::" ]
          add_field => { "[@metadata][src_locality]" => "private" }
        }
        # Check to see if src_locality exists. If it doesn't the src_addr didn't match a private address space and locality must be public.
        if ![@metadata][src_locality] {
          geoip {
            add_tag => [ "GeoIP" ]
            source => "src_ip"
            database => "/etc/logstash/GeoLite2-City.mmdb"
          }
        }
        if [prog] =~ /^suricata/ {
          mutate {
            add_tag => [ "ET-Sig" ]
            add_field => [ "Signature_Info", "http://doc.emergingthreats.net/bin/view/Main/%{[ids_sig_id]}" ]
          }
        }
      }
    }
   if [prog] =~ /^snort/ {
      mutate {
      add_tag => [ "Snort" ]
      }
      grok {
        patterns_dir => ["/etc/logstash/conf.d/patterns"]
        match => [ "message", "%{SNORT}"]
      }
      if ![geoip] and [src_ip] {
        # Check if source IP address is private.
        cidr {
          address => [ "%{[src_ip]}" ]
          network => [ "0.0.0.0/32", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128", "169.254.0.0/16", "fe80::/10", "224.0.0.0/4", "ff00::/8", "255.255.255.255/32", "::" ]
          add_field => { "[@metadata][src_locality]" => "private" }
        }
        # Check to see if src_locality exists. If it doesn't the src_addr didn't match a private address space and locality must be public.
        if ![@metadata][src_locality] {
          geoip {
            add_tag => [ "GeoIP" ]
            source => "src_ip"
            database => "/etc/logstash/GeoLite2-City.mmdb"
          }
        }
        if [prog] =~ /^snort/ {
          mutate {
            add_tag => [ "ET-Sig" ]
            add_field => [ "Signature_Info", "http://doc.emergingthreats.net/bin/view/Main/%{[ids_sig_id]}" ]
          }
        }
      }
    }
    if [prog] =~ /^charon$/ {
      mutate {
        add_tag => [ "ipsec" ]
      }
    }
    if [prog] =~ /^barnyard2/ {
      mutate {
        add_tag => [ "barnyard2" ]
      }
    }
    if [prog] =~ /^openvpn/ {
      mutate {
        add_tag => [ "openvpn" ]
      }
      grok {
        patterns_dir => ["/etc/logstash/conf.d/patterns"]
        match => [ "message", "%{OPENVPN}"]
      }
    }
    if [prog] =~ /^ntpd/ {
      mutate {
        add_tag => [ "ntpd" ]
      }
    }
    if [prog] =~ /^php-fpm/ {
      mutate {
        add_tag => [ "web_portal" ]
      }
      grok {
        patterns_dir => ["/etc/logstash/conf.d/patterns"]
        match => [ "message", "%{PF_APP}%{PF_APP_DATA}"]
      }
      mutate {
        lowercase => [ 'pf_ACTION' ]
      }
    }
    if [prog] =~ /^apinger/ {
      mutate {
        add_tag => [ "apinger" ]
      }
    }
    if [prog] =~ /^filterlog$/ {
      mutate {
        remove_field => [ "msg", "datetime" ]
      }
      grok {
        add_tag => [ "firewall" ]
        patterns_dir => ["/etc/logstash/conf.d/patterns"]
        match => [ "message", "%{PF_LOG_DATA}%{PF_IP_SPECIFIC_DATA}%{PF_IP_DATA}%{PF_PROTOCOL_DATA}",
                   "message", "%{PF_IPv4_SPECIFIC_DATA}%{PF_IP_DATA}%{PF_PROTOCOL_DATA}",
                   "message", "%{PF_IPv6_SPECIFIC_DATA}%{PF_IP_DATA}%{PF_PROTOCOL_DATA}"]
      }
      mutate {
        lowercase => [ 'proto' ]
      }
      if ![geoip] and [src_ip] {
        # Check if source IP address is private.
        cidr {
          address => [ "%{[src_ip]}" ]
          network => [ "0.0.0.0/32", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128", "169.254.0.0/16", "fe80::/10", "224.0.0.0/4", "ff00::/8", "255.255.255.255/32", "::" ]
          add_field => { "[@metadata][src_locality]" => "private" }
        }
        # Check to see if src_locality exists. If it doesn't the src_addr didn't match a private address space and locality must be public.
        if ![@metadata][src_locality] {
          geoip {
            add_tag => [ "GeoIP" ]
            source => "src_ip"
            database => "/etc/logstash/GeoLite2-City.mmdb"
          }
        }
        if ![@metadata][src_locality] {
          geoip {
            add_tag => [ "GeoIP" ]
            source => "src_ip"
            database => "/etc/logstash/GeoLite2-ASN.mmdb"
          }
        }
      }
    }
  }
}
